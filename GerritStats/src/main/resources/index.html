<!DOCTYPE html>
<meta charset="utf-8">
<body>
<script src="res/css-element-queries/ResizeSensor.js"></script>
<script src="res/css-element-queries/ElementQueries.js"></script>
<script src="res/d3.min.js"></script>
<script src="res/jquery.min.js"></script>
<script src="res/jquery.tablesorter.min.js"></script>
<script src="res/bootstrap.min.js"></script>
<script src="res/moment.min.js"></script>
<script src="res/numeral.min.js"></script>
<script src="res/gerritstats.js"></script>
<script src="overview/overview.js"></script>

<head>
    <link type="text/css" rel="stylesheet" media="screen" href="res/bootstrap.css" />
    <link type="text/css" rel="stylesheet" media="screen" href="res/style.css" />
    <title>GerritStats</title>
</head>
<header>
    <table class="filterBox">
        <tr>
            <th><img src="res/ic_branches.png">Branches:</th>
            <td class="filterBoxValue" id="datasetOverviewBranchList"></td>
        </tr>
        <tr>
            <th><span class="glyphicon glyphicon-calendar"></span>From:</th>
            <td class="filterBoxValue" id="datasetOverviewFromDate"></td>
        </tr>
        <tr>
            <th><span class="glyphicon glyphicon-calendar"></span>To:</th>
            <td class="filterBoxValue" id="datasetOverviewToDate"></td>
        </tr>
        <tr>
            <th><span class="glyphicon glyphicon-user"></span>Users in analysis:</th>
            <td class="filterBoxValue" id="datasetOverviewIdentityCount"></td>
        </tr>
    </table>

    <h1>Gerrit Statistics</h1>
    <div class="subtitleH1">for <span id="subtitleDataSetName"></span></div>
</header>
<nav>
    <ul id="navBar" class="nav nav-tabs">
        <li role="presentation" class="active"><a href="#" data-type='users'>Users</a></li>
        <li role="presentation"><a href="#" data-type='connections'>Connections</a></li>
    </ul>
</nav>

<content id="content">
<table id="identities" class="table table-striped">
    <thead>
        <th id="checkboxColumn"><input name='selectAll' type='checkbox' checked='true' onclick='onSelectAllCheckboxClicked(this)' /></th>
        <th id="nameColumn">Name</th>
        <th class="dataField">+2<br>given</th>
        <th class="dataField">+1<br>given</th>
        <th class="dataField">-1<br>given</th>
        <th class="dataField">-2<br>given</th>
        <th class="dataField">Comments<br>written</th>
        <th class="dataField">Comments<br>received</th>
        <th class="dataField">Commits</th>
        <th class="dataField">Comments<br>/ commit</th>
        <th class="dataField">Comments<br>/ review<br>requests</th>
        <th class="dataField">Added as<br>reviewer</th>
        <th class="dataField">Average time<br>in review</th>
    </thead>
    <tbody id="overviewTableBody">
    </tbody>
</table>

<!-- This element is positioned dynamically over the table -->
<div id="proximityGraph" class="proximityGraph" style="display:none">
</div>

<script>
$('nav a').click(function(event) {
    event.preventDefault();
    var navElement = $(this);

    var navType = $(navElement).attr('data-type');
    if (navType === undefined) {
        throw new Error("navType is not defined!");
    }
    navElement.tab('show')

    switch (navType) {
    case 'users':
        $('#proximityGraph').hide();
        break;
    case 'connections':
        $('#proximityGraph').show();
        updateTabBarPosition();
        break;
    }
})

function updateTabBarPosition() {
    var navBar = $('#navBar');

    var checkboxCol = $('#checkboxColumn');
    var connectionsLeftMargin = nameColumn.clientLeft + nameColumn.clientWidth + 50;
    navBar.css('margin-left', connectionsLeftMargin);

    var content = $("#content");
    var proximityGraphObject = $('#proximityGraph');

    if (proximityGraphObject.is(':visible')) {
        proximityGraphObject.css('left', connectionsLeftMargin);
        proximityGraphObject.css('top', navBar.position().top + navBar.height());
        proximityGraphObject.css('height', content.outerHeight());
        proximityGraphObject.css('width', content.outerWidth() - nameColumn.clientWidth);
        proximityGraph.updateSize();
    }
}

var nameColumn = document.getElementById('nameColumn');
new ResizeSensor(nameColumn, updateTabBarPosition);

function onIdentityCheckboxClicked(checkbox) {
    var userIdentifier = $(checkbox).attr('data-identifier');
    if (checkbox.checked) {
        selectedUsers[userIdentifier] = '1';
    } else {
        delete selectedUsers[userIdentifier];
    }

    proximityGraph.render();
}

function onSelectAllCheckboxClicked(checkbox) {
    $('.identityCheckbox').each(function() {
        $(this).prop('checked', checkbox.checked);
        var userIdentifier = $(this).attr('data-identifier');
        if (checkbox.checked) {
            selectedUsers[userIdentifier] = '1';
        } else {
            delete selectedUsers[userIdentifier];
        }
    });

    proximityGraph.render();
}

function getIndexOfIdentity(identity) {
    for (var i = 0; i < overviewUserdata.length; ++i) {
        var user = overviewUserdata[i];
        if ((user.identity.email !== undefined && user.identity.email == identity.email)
         || (user.identity.username !== undefined && user.identity.username == identity.username)) {
            return i;
        }
    }
    return -1;
}

var identityGraphNodes = jQuery.extend(true, [], overviewUserdata);
var identityGraph = {
    "nodes": identityGraphNodes,
    "links":[]
    }

    for (var i = 0; i < overviewUserdata.length; ++i) {
        var item = overviewUserdata[i];
        for (var j = 0; j < item.myReviewerList.length; ++j) {
            var reviewerRecord = item.myReviewerList[j];
            if (reviewerRecord.reviewData.approvalCount != 0) {
                identityGraph.links.push({
                    source: identityGraphNodes[i],
                    target: identityGraphNodes[getIndexOfIdentity(reviewerRecord.identity)],
                    value: reviewerRecord.reviewData.approvalCount
                });
            }
        }
    }

</script>

<script>

function loadOverviewUserdata() {
    var tbody = $('#overviewTableBody')
    overviewUserdata.forEach(function(item) {
        tbody.append(
        '<tr>\
            <td><input class="identityCheckbox" data-identifier="' + item.identifier + '"\
                       type="checkbox" checked="true" onclick="onIdentityCheckboxClicked(this)" /></td>\
            <td><a href="profile.html?user=' + item.identifier + '">' + getPrintableName(item.identity) + '</a></td>\
            <td class="dataField">' + item.reviewCountPlus2 + '</td>\
            <td class="dataField">' + item.reviewCountPlus1 + '</td>\
            <td class="dataField">' + item.reviewCountMinus1 + '</td>\
            <td class="dataField">' + item.reviewCountMinus2 + '</td>\
            <td class="dataField">' + item.allCommentsWritten + '</td>\
            <td class="dataField">' + item.allCommentsReceived + '</td>\
            <td class="dataField">' + item.commitCount + '</td>\
            <td class="dataField" data-value="' + item.receivedCommentRatio + '">' + numeral(item.receivedCommentRatio).format("0.000") + '</td>\
            <td class="dataField" data-value="' + item.reviewCommentRatio + '">' + numeral(item.reviewCommentRatio).format("0.000") + '</td>\
            <td class="dataField">' + item.addedAsReviewerToCount + '</td>\
            <td class="dataField" data-unixtime="' + item.averageTimeInCodeReview + '">' + formatPrintableDuration(item.averageTimeInCodeReview) + '</td>\
        </tr>')
    });
}

function ProximityGraph(identityGraph, objectSelector) {
    this.width = 1200;
    this.height = 800;

    this.lowConnectionColors = [
        '#e6550d', // less connections
        '#fd8d3c',
        '#fdae6b',
        '#fdd0a2', // more connections
    ];

    this.highConnectionColors = [
        '#c7e9c0', // less connections
        '#a1d99b',
        '#74c476',
        '#31a354', // more connections
    ];

    // Source data
    this.identityGraph = identityGraph;

    /** Filter out all the connections that are below the given threshold */
    this.relativeLinkValueThreshold = 0.1;

    // d3
    this.svg = null;

    this.create = function() {
        this.svg = d3.select(objectSelector).append('svg')
            .attr('width', this.width)
            .attr('height', this.height);

        this.forceLayout = d3.layout.force()
            .size([this.width, this.height])
            .charge(-450)
            .linkDistance(45);

        this.render();
    }

    this.updateSize = function() {
        this.width = $(objectSelector).width();
        this.height = $(objectSelector).height();
        this.svg.attr("width", this.width).attr("height", this.height);
        this.forceLayout.size([this.width, this.height]).resume();
    }

    this.render = function() {
        this.svg.html('');

        // TODO; when filtering users, the diagram links are not constructed correctly
        // because the identity graph has indices instead of references to the nodes.
        //
        // The graph's links must be constructed in a different way, so that they contain
        // *references* to nodes, instead of indices.

        var that = this;
        var maxLinkValue = this.getMaxLinkValue(this.identityGraph);

        var nodeData = this.filterNodes(this.identityGraph.nodes);
        var filteredLinks = this.filterLinks(this.identityGraph.nodes,
                                             this.identityGraph.links, maxLinkValue, this.relativeLinkValueThreshold);
        this.findFromNodeData = function(identifier) {
            return nodeData.find(function(node) {
                return node.identifier == identifier;
            });
        };

        var links = filteredLinks.map(function(currentLink, index, array) {
            return {
                source: this.findFromNodeData(currentLink.source.identifier),
                target: this.findFromNodeData(currentLink.target.identifier),
                value: currentLink.value
            }
        }, this);

        var connectionsPerIdentifier = this.createConnectionsPerIdentifierTable(links);
        var connectionCounts = $.map(connectionsPerIdentifier, function(value, key) {
            return value;
        });
        var maxConnectionCount = this.getMaxValueFromArray(connectionCounts);
        var medianConnectionCount = this.getMedianValueFromArrayExcludingZeroes(connectionCounts);

        var commitList = this.filterObjectArray(nodeData, 'commitCount').sort(this.numberComparator);
        var medianCommitCount = this.getMedianValueFromArrayExcludingZeroes(commitList);
        var maxCommitCount = this.getMaxValueFromArray(commitList);

        this.forceLayout
            .nodes(nodeData)
            .links(links)
            .linkStrength(function(d) {
                return 0.1 + (d.value / maxLinkValue);
            })
            .start();

        var link = this.svg.selectAll(".link")
            .data(links)
            .enter().append("line")
            .attr("class", "proximityGraphLink")
            .style("stroke-width", function(d) { return 10 * (d.value / maxLinkValue); });

        var nodes = this.svg.selectAll('.node')
            .data(nodeData);

        nodes.enter().append('circle')
            .attr('class', 'proximityGraphNode')
            .attr('r', function(d) {
                return 3 + 2 * Math.sqrt(d.commitCount / medianCommitCount);
            })
            .style('fill', function(d) {
                var connectionCount = that.getConnectionCount(d.index, links);
                var relativeConnectionCount = connectionCount / medianConnectionCount;
                if (relativeConnectionCount >= 1) {
                    relativeConnectionCount = connectionCount / maxConnectionCount;
                    return that.mapConnectionsToColor(relativeConnectionCount, that.highConnectionColors);
                } else {
                    return that.mapConnectionsToColor(relativeConnectionCount, that.lowConnectionColors);
                }
            })
            .call(this.forceLayout.drag);

        nodes.append('title')
            .text(function(d) { return d.identity.name; });

        this.forceLayout.on('tick', function() {
                 link.attr('x1', function(d) { return d.source.x; })
                     .attr('y1', function(d) { return d.source.y; })
                     .attr('x2', function(d) { return d.target.x; })
                     .attr('y2', function(d) { return d.target.y; })
                nodes.attr('cx', function(d) { return d.x; })
                     .attr('cy', function(d) { return d.y; });
        });
    }

    this.getMaxLinkValue = function(graph) {
        var that = this;
        return graph.links.reduce(function(previousValue, currentLink, index, links) {
            if (that.isLinkSelected(graph.nodes, currentLink)) {
                return Math.max(previousValue, currentLink.value);
            } else {
                return previousValue;
            }
        }, -1);
    }

    this.filterNodes = function(nodeData) {
        var that = this;
        return nodeData.filter(function(node, index, array) {
            return that.isNodeSelected(node.identifier);
        }, []);
    }

    this.isNodeSelected = function(identifier) {
        return selectedUsers[identifier] === '1';
    }

    this.isLinkSelected = function(nodes, link) {
        return this.isNodeSelected(link.source.identifier)
            && this.isNodeSelected(link.target.identifier);
    }

    /**
     * Filter out the links that are below the given relative percentage, between [0..1].
     * For example, if relativeThreshold is 0.1, all links that have under 10% of the maximum
     * interaction are filtered out.
     */
    this.filterLinks = function(nodes, links, maxLinkValue, relativeThreshold) {
        var that = this;
        var sourceLinks = jQuery.extend(true, [], links);
        return sourceLinks.filter(function(currentLink, index, array) {
            return (currentLink.value / maxLinkValue) >= relativeThreshold
                && that.isLinkSelected(nodes, currentLink);
        }, []);
    }

    this.getConnectionCount = function(nodeIndex, links) {
        var connectionCount = 0;
        for (var i = 0; i < links.length; ++i) {
            if (links[i].source.index == nodeIndex || links[i].target.index == nodeIndex) {
                connectionCount += links[i].value;
            }
        }
        return connectionCount;
    }

    this.isVarDefined = function(variable) {
        return typeof variable !== 'undefined';
    }

    this.safeIncrement = function(initialValue, toAdd) {
        return !this.isVarDefined(initialValue) ? toAdd : initialValue + toAdd;
    }

    this.createConnectionsPerIdentifierTable = function(links) {
        var connectionsPerIdentifier = {};
        for (var i = 0; i < links.length; ++i) {
            var connectionCount = links[i].value;
            var sourceConnections = connectionsPerIdentifier[links[i].source.identifier];
            var targetConnections = connectionsPerIdentifier[links[i].target.identifier];
            connectionsPerIdentifier[links[i].source.identifier] = this.safeIncrement(sourceConnections, connectionCount);
            connectionsPerIdentifier[links[i].target.identifier] = this.safeIncrement(targetConnections, connectionCount);
        }
        return connectionsPerIdentifier;
    }

    this.numberComparator = function(left, right) {
        return left - right;
    }

    this.filterObjectArray = function(objectList, key) {
        return objectList.map(function(currentValue, index, array) {
            return currentValue[key];
        }, []);
    }

    this.getMaxValueFromArray = function(list) {
        return list.reduce(function(previousValue, currentValue, index, array) {
            return Math.max(previousValue, currentValue);
        }, -1);
    }

    this.getMedianValueFromArrayExcludingZeroes = function(list) {
        var sortedList = list.slice().filter(function(currentValue, index, array) {
            return currentValue !== undefined;
        })
        .sort(this.numberComparator);
        var lastZero = sortedList.lastIndexOf(0);
        if (lastZero == -1) {
            lastZero = 0;
        }
        return sortedList[lastZero + Math.floor((sortedList.length - lastZero) / 2)];
    }

    this.mapConnectionsToColor = function(relativeConnectionCount, colors) {
        var colorIndex = Math.min(colors.length - 1, Math.floor(relativeConnectionCount * colors.length));
        return colors[colorIndex];
    }

    this.create(identityGraph);
}

var selectedUsers = {};
identityGraph.nodes.forEach(function(node) {
    selectedUsers[node.identifier] = '1'
});

var proximityGraph = new ProximityGraph(identityGraph, '#proximityGraph');

loadOverviewUserdata();

$(document).ready(function() {
    document.title = "GerritStats for " + datasetOverview.projectName;
    var dataSetName = datasetOverview.projectName;
    if (datasetOverview.filenames.length > 20) {
        var firstFilename = datasetOverview.filenames[0];
        var lastFilename = datasetOverview.filenames[datasetOverview.filenames.length - 1];
        dataSetName = datasetOverview.filenames.length + " files, from "
                    + firstFilename + " to " + lastFilename
    }
    $('#subtitleDataSetName').html(dataSetName);

    $('#datasetOverviewBranchList').html(datasetOverview.branchList);
    $('#datasetOverviewFromDate').html(moment(datasetOverview.fromDate).format("YYYY-MM-DD"));
    $('#datasetOverviewToDate').html(moment(datasetOverview.toDate).format("YYYY-MM-DD"));
    $('#datasetOverviewIdentityCount').html(overviewUserdata.length);

    $.tablesorter.addParser({
        id: 'timeInReview',
        is: function(s) {
            return false;
        },
        format: function(s, table, cell, cellIndex) {
            return $(cell).attr('data-unixtime');
        },
        type: 'numeric'
    });
    $.tablesorter.addParser({
            id: 'decimal',
            is: function(s) {
                return false;
            },
            format: function(s, table, cell, cellIndex) {
                return $(cell).attr('data-value');
            },
            type: 'numeric'
    });

    $('#identities').tablesorter({
        headers: {
            0: { // checkbox column
                sorter: false
            },
            9: {
                sorter: 'decimal'
            },
            10: {
                sorter: 'decimal'
            },
            12: {
                sorter:'timeInReview'
            }
        }
    });
});

</script>
</content>
</body>